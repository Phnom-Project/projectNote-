## CyberSecurity :crossed_swords:
- ####  Cross-site scripting (xxs)
    cross-site scripting attacks, whereby an attacker injects JavaScript into the pages of your site when users view them. Attackers usually inject malicious JavaScript into dynamic content that comes from a database, from the HTTP request, or from the URI fragment. You can defeat cross-site scripting attacks by escaping any HTML control characters in dynamic content, and by setting a content security policy that prevents the execution of inline JavaScript.
    - **Database** : attacker can insert **(<script></script>)** in field like as **comment sections, search results, and URLs ...** then i will save in database, and when user get these comment, post (that script will execute).
    - **Client browser** : attacker send link with script can execute in user browser when click on it.
- ####  Cross-site Request Forgery Attacks (CRFA)
    Attackers can use web requests from other sites to trick your users into performing undesired actions. 
    The solution to such cross-site request forgery attacks is threefold. 
    - First, make sure your GET requests are side-effect free, so the server state is not changed when a user clicks malicious links.
      ```
      GET/RegisterStudent.asp?user=value1&pass=value2
      ```  
      
      ```
      POST/RegisterStudent.asp HTTP/1.1  
      Host: www.guru99.com
      user=value1&pass=value2
      ```
    - Second, use anti-CSRF cookies to protect other types of requests.
    - Third, set these cookies with a SameSite attribute to strip cookies from requests generated by other sites.   
    > ***For very sensitive actions on your site, it‚Äôs a good idea to require the user to reauthenticate themselves when they request to perform these actions. This adds an     additional layer of protection against CSRF attacks, and protects your users if they accidentally leave themselves logged in on shared or stolen devices.***
- #### Compromising Authentication
    Hackers often attempt to attack your authentication system in an effort to steal your users‚Äô credentials.
    - ##### Requiring Usernames, Email Address, or Both : 
        - Validating Email Addresses,
        - Banning Disposable Email Accounts
        - The only reliable way to validate an email address is to send it an email containing a link with a unique, temporary validation token that your site can check when the user clicks it.
    - ##### Securely Storing Passwords : From breach user data password that can use these to attack by brute-force , rainbow table attack
        - Requiring Complex Passwords
        - Hashing Passwords, Salting Hashes : random salting hash For make nobody can know this plaintext-password
        - Implementing and Securing the Logout Function : clear **cookie** from browser For protect steal after log-out.( simple as sending back an HTTP response containing a Set-Cookie header with a blank value for your session parameter)
    - #### Preventing User Enumeration 
        - Preventing Potential Enumeration Vulnerabilities : For example, simply use the error message an **incorrect username or password** was entered whenever the username is unrecognized or the password is incorrect.
        - If an attacker clicks a ‚ÄúForgotten password‚Äù link and types in an email address to request a password-reset link, the response message on the page shouldn‚Äôt reveal whether a reset email was sent. This prevents the attacker from knowing whether that email address is tied to an account on your site. Keep the message neutral: something like **Check your inbox**. 
        - Attackers may also use timing attacks to enumerate users by measuring HTTP response times. Hashing a password is a time-consuming operation;
    - #### Implementing CAPTCHA    
- #### Session Hijacking
    - ##### Cross-Site Scripting
        - An attacker will try to use JavaScript injected into a user‚Äôs browser to read the user‚Äôs cookies and send them to an external web server that the attacker controls. The attacker will then harvest these cookies as they appear in the web server‚Äôs log file, and then cut and paste the cookie values into a browser session‚Äîor more likely, add them to a script‚Äîto perform actions under the hacked user‚Äôs session.
        - üîêTo defuse session hijacking via cross-site scripting, mark all cookies as HttpOnly in the Set-Cookie header. This tells the browser not to make cookies available to JavaScript code.
        ```
        Set-Cookie: session_id=278283910977381992837; HttpOnly
        ```
    - ##### Man-in-the-Middle Attacks
        - An attacker can also steal cookies by using a man-in-the-middle attack: the attacker finds a way to sit between the browser and the web server and read network traffic as it passes back and forth. To protect against cookie theft via man-in-the-middle attacks, your website should use HTTPS.
        - üîêAfter you‚Äôve enabled HTTPS on the web server, you should mark your cookies as Secure, as shown below, so the browser knows to never send unencrypted cookies over HTTP.
        ```
        Set-Cookie: session_id=278283910977381992837; Secure
        ```
    - ##### 
    - ##### 

## CyberSecurity :crossed_swords:
- ### 1 Cross-site scripting (xxs)
    cross-site scripting attacks, whereby an attacker injects JavaScript into the pages of your site when users view them. Attackers usually inject malicious JavaScript into dynamic content that comes from a database, from the HTTP request, or from the URI fragment. You can defeat cross-site scripting attacks by escaping any HTML control characters in dynamic content, and by setting a content security policy that prevents the execution of inline JavaScript.
    - **Database** : attacker can insert **(<script></script>)** in field like as **comment sections, search results, and URLs ...** then i will save in database, and when user get these comment, post (that script will execute).
    - **Client browser** : attacker send link with script can execute in user browser when click on it.
- ### 2 Cross-site Request Forgery Attacks (CRFA)
    Attackers can use web requests from other sites to trick your users into performing undesired actions. 
    The solution to such cross-site request forgery attacks is threefold. 
    - First, make sure your GET requests are side-effect free, so the server state is not changed when a user clicks malicious links.
      ```
      GET/RegisterStudent.asp?user=value1&pass=value2
      ```  
      
      ```
      POST/RegisterStudent.asp HTTP/1.1  
      Host: www.guru99.com
      user=value1&pass=value2
      ```
    - Second, use anti-CSRF cookies to protect other types of requests.
    - Third, set these cookies with a SameSite attribute to strip cookies from requests generated by other sites.   
    > ***For very sensitive actions on your site, it‚Äôs a good idea to require the user to reauthenticate themselves when they request to perform these actions. This adds an     additional layer of protection against CSRF attacks, and protects your users if they accidentally leave themselves logged in on shared or stolen devices.***
- ### 3 Compromising Authentication
    Hackers often attempt to attack your authentication system in an effort to steal your users‚Äô credentials.
    - ##### Requiring Usernames, Email Address, or Both : 
        - Validating Email Addresses,
        - Banning Disposable Email Accounts
        - The only reliable way to validate an email address is to send it an email containing a link with a unique, temporary validation token that your site can check when the user clicks it.
    - ##### Securely Storing Passwords : From breach user data password that can use these to attack by brute-force , rainbow table attack
        - Requiring Complex Passwords
        - Hashing Passwords, Salting Hashes : random salting hash For make nobody can know this plaintext-password
        - Implementing and Securing the Logout Function : clear **cookie** from browser For protect steal after log-out.( simple as sending back an HTTP response containing a Set-Cookie header with a blank value for your session parameter)
    - #### Preventing User Enumeration 
        - Preventing Potential Enumeration Vulnerabilities : For example, simply use the error message an **incorrect username or password** was entered whenever the username is unrecognized or the password is incorrect.
        - If an attacker clicks a ‚ÄúForgotten password‚Äù link and types in an email address to request a password-reset link, the response message on the page shouldn‚Äôt reveal whether a reset email was sent. This prevents the attacker from knowing whether that email address is tied to an account on your site. Keep the message neutral: something like **Check your inbox**. 
        - Attackers may also use timing attacks to enumerate users by measuring HTTP response times. Hashing a password is a time-consuming operation;
    - #### Implementing CAPTCHA    
- ### 4 Session Hijacking
    When a website successfully authenticates a user, the browser and the server open a session between them. Session state can be stored on the server side, or stored on the client side as an encrypted or digitally signed cookie. Session Hijacking 101Hackers will attempt to steal your session cookies, so you should ensure they‚Äôre protected. 
     ```
     üîê Set-Cookie: session_id=278283910977381992837; HttpOnly; Secure; SameSite=Lax
     ```
    - ##### Cross-Site Scripting
        - An attacker will try to use JavaScript injected into a user‚Äôs browser to read the user‚Äôs cookies and send them to an external web server that the attacker controls. The attacker will then harvest these cookies as they appear in the web server‚Äôs log file, and then cut and paste the cookie values into a browser session‚Äîor more likely, add them to a script‚Äîto perform actions under the hacked user‚Äôs session.
        - üîêTo defuse session hijacking via cross-site scripting, mark all cookies as HttpOnly in the Set-Cookie header. This tells the browser not to make cookies available to JavaScript code.
        ```
        Set-Cookie: session_id=278283910977381992837; HttpOnly
        ```
    - ##### Man-in-the-Middle Attacks
        - An attacker can also steal cookies by using a man-in-the-middle attack: the attacker finds a way to sit between the browser and the web server and read network traffic as it passes back and forth. To protect against cookie theft via man-in-the-middle attacks, your website should use HTTPS.
        - üîêAfter you‚Äôve enabled HTTPS on the web server, you should mark your cookies as Secure, as shown below, so the browser knows to never send unencrypted cookies over HTTP.
        ```
        Set-Cookie: session_id=278283910977381992837; Secure
        ```
    - ##### Cross-Site Request Forgery
        - An attacker using CSRF doesn‚Äôt need to get access to a user‚Äôs session cookie. Instead, they simply need to trick the victim into clicking a link to your site. If the user already has a session open on your site, the browser will send their session cookie along with the HTTP request triggered by the link, which might result in the user inadvertently performing a sensitive action (such as Liking an item the hacker is attempting to promote).
        - üîêTo defuse CSRF attacks, mark your cookies with the SameSite attribute, which instructs the browser to send only session cookies with HTTP requests generated from your site. The browser will strip session cookies from other HTTP requests, like those generated by clicking a link in an email.
            -  The Strict setting, shown below, has the advantage of stripping cookies from all HTTP requests triggered from external sites
            ```
            Set-Cookie: session_id=278283910977381992837; SameSite=Strict
            ```
            - The Strict setting can prove annoying if a user shares your content via social media, because the setting forces anyone clicking their link to log in again to view the content. To solve this annoyance for your users, configure the browser to allow cookies only on GET requests by using the SameSite=Lax setting,
            ```
            Set-Cookie: session_id=278283910977381992837; SameSite=Lax
            ```
    - ##### Session Fixation ,fixate (find or set)
        - First, writing session IDs in the URL allows them to be leaked in log files. An attacker who gets access to your logs can hijack your users‚Äô sessions simply by dropping these types of URLs in the browser.The second issue is a vulnerability called session fixation. When web servers vulnerable to session fixation encounter an unknown session ID in a URL, they‚Äôll ask the user to authenticate themselves, and then establish a session under the supplied session ID. This allows a hacker to fixate the session ID ahead of time, sending victims tempting links (usually in unsolicited email or spam in a site‚Äôs comment sections) with the fixated session ID. Any user who clicks the link can have their session hijacked, because the attacker can simply use that same URL in their own browser, having fixed the session ID ahead of time. The act of clicking the link and logging it transforms the dummy session ID into a real session ID‚Äîone that the hacker knows.
        ```
        http://www.example.com/catalog/index.html;jsessionid=1234
        ```
        - üîêIf your web server supports URL rewriting as a means of session tracking, you should disable it with the relevant configuration options. It serves no purpose and exposes you to session fixation attacks. Listing 10-9 shows how to disable URL rewriting in version 7.0 of the popular Java web server Apache Tomcat by editing the web.xml config file.
        ```xml
        <session-config>
            <tracking-mode>COOKIE</tracking-mode>
        </session-config>
        ```
    - ##### Taking Advantage of Weak Session IDs
        - Early versions of the standard Apache Tomcat server were found to be vulnerable to this type of attack. Security researchers discovered that the seeds of the random session ID generation algorithm were the system time and the hashcode of an in-memory object. The researchers were able to use these seeds to narrow the potential input values in such a way that they could reliably guess session IDs.Consult your web server‚Äôs documentation and ensure that it uses large session IDs that can‚Äôt be guessed, generated by a strong random number generation algorithm. Because security researchers frequently discover weak session ID algorithms before attackers can exploit them.
- ### 5 Permissions
    - ##### Privilege Escalation
        - vertical escalation, an attacker gets access to an account with broader permissions than their own. If an attacker can deploy a web shell on your server‚Äîan executable script that takes elements of the HTTP request and runs them on the command line‚Äîone of their first aims will be to escalate their way to root privilege, so they can perform any actions they wish on the server. Ordinarily, commands sent to the web shell will be executed under the same operating system account that the web server is running, which generally has limited network and disk access. Hackers have found a lot of ways to perform vertical escalation attacks on operating systems in an attempt to get root access‚Äîwhich allows them to infect the whole server from a web shell.
        - horizontal escalation, an attacker accesses another account with similar privileges as their own. In the last couple of chapters, we‚Äôve discussed common ways of performing this type of attack: guessing passwords, hijacking sessions, or maliciously crafting HTTP request data. The September 2018 Facebook hack was an example of horizontal escalation, caused by an API that issued access tokens without correctly verifying the user‚Äôs permissions.
    - #####  Access Control
        - üîê Authentication Correctly identifying a user when they return to the site
        - üîê Authorization Deciding which actions a user should and shouldn‚Äôt be able to perform after they‚Äôve identified themselves
        - üîê Permission checking Evaluating authorization at the point in time when a user attempts to perform an action
            - Access Control Lists  (ACLs) are a simple way of modeling authorization that attach against each object in your system a list of permissions, specifying 
the actions that each user or account can perform on that object. The canonical example of an ACL-based model is the Linux filesystem, which can individually granteach user read, write, or execute permissions on each file and directory.
            - Whitelists and Blacklists : A whitelist describes the users or accounts that can access a particular resource, and bans all other users. A blacklist explicitly describes the users or accounts that are banned from accessing a resource, implying that the resource should be made accessible to any other user or account.
            - Role-Based Access Control :  Amazon Web Services identity and access management (IAM) system is an example of a comprehensive role-based system, as is Microsoft‚Äôs Active Directory.
            - Adding Audit Trails : to help with troubleshooting and forensic analysis. Audit trails are log files or database entries that are recorded whenever a user performs an action. Simply adding logging statements as users navigate your site (14:32:06 2019-02-05: User example @gmail.com logged in) can help you diagnose any problems as they occur at runtime, and provide vital evidence in the event that you do get hacked.
    - ##### Directory Traversal
       > Consider a shopping application that displays images of items for sale. Images are loaded via some HTML like the following:
       ```
       <img src="/loadImage?filename=218.png">
       ```
       > The loadImage URL takes a filename parameter and returns the contents of the specified file. The image files themselves are stored on disk in the location **/var/www/images/**. To return an image, the application appends the requested filename to this base directory and uses a filesystem API to read the contents of the file. In the above case, the application reads from the following file path:
       ```
       /var/www/images/218.png
       ```
       > The application implements no defenses against directory traversal attacks, so an attacker can request the following URL to retrieve an arbitrary file from the server's filesystem:
       ```
       https://insecure-website.com/loadImage?filename=../../../etc/passwd
       ```
       > This causes the application to read from the following file path:
       ```
       /var/www/images/../../../etc/passwd
       ```
       > The sequence **../** is valid within a file path, and means to step up one level in the directory structure. The three consecutive **../** sequences step up from **/var/www/images/** to the filesystem root, and so the file that is actually read is:
       ```
       /etc/passwd
       ```
       > On Unix-based operating systems, this is a standard file containing details of the users that are registered on the server. On Windows, both ../ and ..\ are valid directory traversal sequences, and an equivalent attack to retrieve a standard operating system file would be:
       ```
       https://insecure-website.com/loadImage?filename=..\..\..\windows\win.ini
       ```
       > üîê [https://portswigger.net/web-security/file-path-traversal](https://portswigger.net/web-security/file-path-traversal)
- ### 6 INFORMATION LEAKS ‚ö†
    You should ensure that your web server doesn‚Äôt leak information about the type of software stack you‚Äôre running on, because hackers will use this information against you when trying to figure out how to compromise your website 
    - ##### üîê Disable Telltale Server Headers 
        - Make sure to disable any HTTP response headers in your web server configuration that reveal the server technology, language, and version you‚Äôre running. By default, web servers usually send a Server header back with each response, describing which software is running on the server side. This is great advertising for the web server vendor, but the browser doesn‚Äôt use it. It simply tells an attacker which vulnerabilities they can probe for. Make sure your web server configuration disables this Server header. 
    - ##### üîê Use Clean URLs
        - When you design your website, avoid telltale file suffixes in URLs, such as .php, .asp, and .jsp. Implement clean URLs instead‚ÄîURLs that do not give away implementation details. URLs with file extensions are common in older web servers, which explicitly reference template filenames. Make sure to avoid such extensions.
    - ##### üîê Use Generic Cookie Parameters 
        - The name of the cookie your web server uses to store session state frequently reveals your server-side technology. For instance, Java web servers usually store the session ID under a cookie named JSESSIONID. Attackers can check these kinds of session cookie names to identify servers : 
        > The hacking tool Metasploit attempting to detect and compromise an Apache 
Tomcat server
        ```java
        if response.get_cookies.match(/JSESSIONID=(.*);(.*)/i)
        jsessionid = $1
        post_data = "j_username=#{username}&j_password=#{password}"
        response = send_request_cgi({
        'uri' => '/admin/j_security_check',
        'method' => 'POST',
        'content-type' => 'application/x-www-form-urlencoded',
        'cookie' => "JSESSIONID=#{jsessionid}",
        'data' => post_data,
        })
        ```
        > Note that the Metasploit code checks the name of the session cookie u. Make sure that your web server sends nothing back in cookies that give clues about your technology stack. Change your configuration to use generic names for the session cookie (for example, session).
    - ##### üîê Disable Client-Side Error Reporting      
        - Most web servers support client-side error reporting, which allows the server to print stack traces and routing information in the HTML of the error page. Client-side error reporting is really useful when debugging errors in test environments. However, stack traces and error logs also tell an attacker which modules or libraries you‚Äôre using, helping them pick out security vulnerabilities to target. Errors occurring in your data access layer can even reveal details about the structure of your database, which is a major security hazard! You must disable error reporting on the client side in your production environment. You should keep the error page your users see completely generic. At most, users should know that an unexpected error occurred and that someone is looking into the problem. Detailed error reports should be kept in production logs and error reporting tools, which only administrators can access. 
    - ##### üîê Minify or Obfuscate Your JavaScript Files
        - Many web developers preprocess their JavaScript code before deploying it by using a minifier, which takes JavaScript code and outputs a functionally equivalent but highly compressed JavaScript file. Minifiers remove all extraneous characters (such as whitespace) and replace some code statements with shorter, semantically identical statements. A related tool is an obfuscator, which replaces method and function names with short, meaningless tokens without changing any behavior in the code, deliberately making the code less readable. The popular UglifyJS utility has both capabilities, and can be invoked directly from the command line with the syntax uglifyjs [input files], which makes it straightforward to plug into your build process. Developers usually minify or obfuscate JavaScript code for performance, because smaller JavaScript files load faster in the browser. This preprocessing also has the positive side effect of making it harder for an attacker to detect which JavaScript libraries you‚Äôre using. Researchers or attackers periodically discover security vulnerabilities in popular JavaScript libraries that permit cross-site scripting attacks. Making it harder to detect the libraries you‚Äôre using will give you more breathing room when exploits are discovered.
    - ##### üîê Sanitize Your Client-Side Files
        - It‚Äôs important that you conduct code reviews and use static analysis tools to make sure sensitive data doesn‚Äôt end up in comments or that dead code doesn‚Äôt get passed to the client. It‚Äôs easy for developers to leave comments in HTML files, template files, or JavaScript files that share a little too much information, since we forget that these files get shipped to the browser. Minifying JavaScript might strip comments, but you need to spot sensitive comments in template files and hand-coded HTML files during code reviews and remove them. Hacking tools make it easy for an attacker to crawl your site and extract any comments that you‚Äôve accidentally left behind‚Äîhackers often use this technique to scan for private IP addresses accidentally left in comments. This is often a first port of call when a hacker is attempting to compromise your website. 
        ```html
        <!--This is a comment. Comments are not displayed in the browser-->
        <p>This is a paragraph.</p>
        ```
        ```js
        /*
        The code below will change the heading with id = "myH" and the paragraph with id = "myP" in my web page:
        */
        document.getElementById("myH").innerHTML = "My First Page";
        ```
